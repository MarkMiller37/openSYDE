//----------------------------------------------------------------------------------------------------------------------
/*!
   \file
   \brief       Utility class for C code export.

   Handles generic code structures of export classes for Datapool, COMM and HALC export.

   \copyright   Copyright 2019 Sensor-Technik Wiedemann GmbH. All rights reserved.
*/
//----------------------------------------------------------------------------------------------------------------------

/* -- Includes ------------------------------------------------------------------------------------------------------ */
#include "precomp_headers.h"

#include "stwtypes.h"
#include "stwerrors.h"
#include "TGLFile.h"
#include "C_OSCExportUti.h"

#include "C_OSCLoggingHandler.h"

/* -- Used Namespaces ----------------------------------------------------------------------------------------------- */
using namespace stw_types;
using namespace stw_errors;
using namespace stw_scl;
using namespace stw_tgl;
using namespace stw_opensyde_core;

/* -- Module Global Constants --------------------------------------------------------------------------------------- */

/* -- Types --------------------------------------------------------------------------------------------------------- */

/* -- Global Variables ---------------------------------------------------------------------------------------------- */

/* -- Module Global Variables --------------------------------------------------------------------------------------- */

/* -- Module Global Function Prototypes ----------------------------------------------------------------------------- */

/* -- Implementation ------------------------------------------------------------------------------------------------ */

//----------------------------------------------------------------------------------------------------------------------
/*! \brief  Default constructor
*/
//----------------------------------------------------------------------------------------------------------------------
C_OSCExportUti::C_OSCExportUti(void)
{
}

//----------------------------------------------------------------------------------------------------------------------
/*! \brief  Create 120 characters long section separator.

   \param[in]  orc_SectionName   Name of the following code section (e.g. Includes, Global Variables, ...)

   \return
   Section separator as string
*/
//----------------------------------------------------------------------------------------------------------------------
C_SCLString C_OSCExportUti::h_GetSectionSeparator(const C_SCLString & orc_SectionName)
{
   C_SCLString c_Return;

   c_Return = "/* -- ";
   c_Return += orc_SectionName;
   c_Return += " ";

   for (uint32 u32_UpfillCounter = 117 - c_Return.Length(); u32_UpfillCounter > 0; u32_UpfillCounter--)
   {
      c_Return += "-";
   }

   c_Return += " */"; // last 3 characters to fill up 120

   return c_Return;
}

//----------------------------------------------------------------------------------------------------------------------
/*! \brief  Get 120 characters long class header separator

   \return
   Class header separator
*/
//----------------------------------------------------------------------------------------------------------------------
C_SCLString C_OSCExportUti::h_GetHeaderSeparator(void)
{
   const C_SCLString c_Return =
      "//--------------------------------------------------------------------------------------------------------------"
      "--------";

   return c_Return;
}

//----------------------------------------------------------------------------------------------------------------------
/*! \brief  Create string with information that the file was generated.

   \param[in]  orc_ExportToolInfo   Export tool info

   \return
   generation information string
*/
//----------------------------------------------------------------------------------------------------------------------
C_SCLString C_OSCExportUti::h_GetCreationToolInfo(const C_SCLString & orc_ExportToolInfo)
{
   return "   This file was generated by openSYDE " + orc_ExportToolInfo + ".";
}

//----------------------------------------------------------------------------------------------------------------------
/*! \brief  Add start for extern C structure.

   \param[in]  orc_Data    File data to append structure to
*/
//----------------------------------------------------------------------------------------------------------------------
void C_OSCExportUti::h_AddExternCStart(C_SCLStringList & orc_Data)
{
   orc_Data.Append("#ifdef __cplusplus");
   orc_Data.Append("extern \"C\" {");
   orc_Data.Append("#endif");
   orc_Data.Append("");
}

//----------------------------------------------------------------------------------------------------------------------
/*! \brief  Add end for extern C structure.

   \param[in]  orc_Data    File data to append structure to
*/
//----------------------------------------------------------------------------------------------------------------------
void C_OSCExportUti::h_AddExternCEnd(C_SCLStringList & orc_Data)
{
   orc_Data.Append("#ifdef __cplusplus");
   orc_Data.Append("} /* end of extern \"C\" */");
   orc_Data.Append("#endif");
   orc_Data.Append("");
}

//----------------------------------------------------------------------------------------------------------------------
/*! \brief  Add define with project ID to ensure file consistency between .c and .h file.

   \param[out]  orc_Data         File data as string list
   \param[in]   orc_MagicName    Magic name including project ID
   \param[in]   oq_HeaderFile    Flag if .c or .h file (true: header file)
*/
//----------------------------------------------------------------------------------------------------------------------
void C_OSCExportUti::h_AddProjectIdDef(C_SCLStringList & orc_Data, const C_SCLString & orc_MagicName,
                                       const bool oq_HeaderFile)
{
   if (oq_HeaderFile == true)
   {
      orc_Data.Append("///unique ID to ensure consistency between .h and .c files");
      orc_Data.Append("#define " + orc_MagicName + " void " + orc_MagicName.LowerCase() + "(void) {}");
      orc_Data.Append("");
   }
   else
   {
      orc_Data.Append("///ensure file consistency (if compilation fails here the .h file does not match this .c file)");
      orc_Data.Append(orc_MagicName);
      orc_Data.Append("");
   }
}

//----------------------------------------------------------------------------------------------------------------------
/*! \brief  Add function prototype section with magic name

   \param[out]  orc_Data         File data as string list
   \param[in]   orc_MagicName    Magic name including project ID
*/
//----------------------------------------------------------------------------------------------------------------------
void C_OSCExportUti::h_AddProjIdFunctionPrototype(C_SCLStringList & orc_Data, const C_SCLString & orc_MagicName)
{
   orc_Data.Append(C_OSCExportUti::h_GetSectionSeparator("Function Prototypes"));
   orc_Data.Append("///unique ID to ensure consistency between .h and .c files");
   orc_Data.Append("extern void " + orc_MagicName.LowerCase() + "(void);");
   orc_Data.Append("");
}

//----------------------------------------------------------------------------------------------------------------------
/*! \brief   Store assembled data in file

   \param[in]  orc_Data       File data as string list
   \param[in]  orc_Path       Directory path for created file excluding file name
   \param[in]  orc_FileName   File name excluding file extension
   \param[in]  oq_HeaderFile  Flag if .c or .h file (true: header file)

   \return
   C_NO_ERR Operation success
   C_RD_WR  Operation failure: cannot store file
*/
//----------------------------------------------------------------------------------------------------------------------
sint32 C_OSCExportUti::h_SaveToFile(stw_scl::C_SCLStringList & orc_Data, const stw_scl::C_SCLString & orc_Path,
                                    const stw_scl::C_SCLString & orc_FileName, const bool oq_HeaderFile)
{
   sint32 s32_Retval = C_NO_ERR;
   C_SCLString c_PathAndFilename;

   // get file path: path + filename + extension
   // add path + add filename + extension
   c_PathAndFilename = orc_Path + "/" + orc_FileName;

   if (oq_HeaderFile == true)
   {
      c_PathAndFilename += ".h";
   }
   else
   {
      c_PathAndFilename += ".c";
   }

   // store into file
   try
   {
      orc_Data.SaveToFile(c_PathAndFilename);
   }
   catch (...)
   {
      osc_write_log_error("Creating source code", "Could not write to file \"" + c_PathAndFilename + "\"");
      s32_Retval = C_RD_WR;
   }

   return s32_Retval;
}

//----------------------------------------------------------------------------------------------------------------------
/*! \brief  Add .c and .h file paths to file paths list.

   \param[in,out]    orc_FilePaths     List of file paths
   \param[in]        orc_Path          Base path of files to add
   \param[in]        orc_FileName      File base name of files to add
*/
//----------------------------------------------------------------------------------------------------------------------
void C_OSCExportUti::h_CollectFilePaths(std::vector<C_SCLString> & orc_FilePaths, const C_SCLString & orc_Path,
                                        const C_SCLString & orc_FileName)
{
   C_SCLString c_FileName;

   c_FileName = TGL_FileIncludeTrailingDelimiter(orc_Path) + orc_FileName;
   orc_FilePaths.push_back(c_FileName + ".h");
   orc_FilePaths.push_back(c_FileName + ".c");
}

//----------------------------------------------------------------------------------------------------------------------
/*! \brief   Get type prefix according to data type

   \param[in]  oe_Type     data type (uint8, sint8, ...)
   \param[in]  oq_IsArray  data type is an array

   \return
   data type as variable prefix string
*/
//----------------------------------------------------------------------------------------------------------------------
C_SCLString C_OSCExportUti::h_GetTypePrefix(const C_OSCNodeDataPoolContent::E_Type oe_Type, const bool oq_IsArray)
{
   C_SCLString c_Prefix;

   if (oq_IsArray == true)
   {
      c_Prefix = "a";
   }
   else
   {
      c_Prefix = "";
   }

   switch (oe_Type)
   {
   case C_OSCNodeDataPoolContent::eUINT8: // Data type unsigned 8 bit integer
      c_Prefix += "u8";
      break;
   case C_OSCNodeDataPoolContent::eUINT16: // Data type unsigned 16 bit integer
      c_Prefix += "u16";
      break;
   case C_OSCNodeDataPoolContent::eUINT32: // Data type unsigned 32 bit integer
      c_Prefix += "u32";
      break;
   case C_OSCNodeDataPoolContent::eUINT64: // Data type unsigned 64 bit integer
      c_Prefix += "u64";
      break;
   case C_OSCNodeDataPoolContent::eSINT8: // Data type signed 8 bit integer
      c_Prefix += "s8";
      break;
   case C_OSCNodeDataPoolContent::eSINT16: // Data type signed 16 bit integer
      c_Prefix += "s16";
      break;
   case C_OSCNodeDataPoolContent::eSINT32: // Data type signed 32 bit integer
      c_Prefix += "s32";
      break;
   case C_OSCNodeDataPoolContent::eSINT64: // Data type signed 64 bit integer
      c_Prefix += "s64";
      break;
   case C_OSCNodeDataPoolContent::eFLOAT32: // Data type 32 bit floating point
      c_Prefix += "f32";
      break;
   case C_OSCNodeDataPoolContent::eFLOAT64: // Data type 64 bit floating point
      c_Prefix += "f64";
      break;
   default:
      break;
   }

   return c_Prefix;
}

//----------------------------------------------------------------------------------------------------------------------
/*! \brief  Get C variable name for a Datapool list element.

   \param[in]  orc_Name       Name
   \param[in]  oq_IsArray     Flag if array
   \param[in]  oe_Type        Content type
   \param[in]  orc_ArrayPos   Array position

   \return
   C variable name for given Datapool list element
*/
//----------------------------------------------------------------------------------------------------------------------
C_SCLString C_OSCExportUti::h_GetElementCName(const C_SCLString & orc_Name, const bool oq_IsArray,
                                              const C_OSCNodeDataPoolContent::E_Type oe_Type,
                                              const C_SCLString & orc_ArrayPos)
{
   C_SCLString c_Return = C_OSCExportUti::h_GetTypePrefix(oe_Type, oq_IsArray) + "_" + orc_Name;

   if (oq_IsArray == true)
   {
      c_Return += "[" + orc_ArrayPos + "]";
   }

   return c_Return;
}

//----------------------------------------------------------------------------------------------------------------------
/*! \brief  Utility wrapper for C_SCLString::FloatToStr that cuts trailing zeroes.

   Call C_SCLString::FloatToStr and cut all trailing zeroes.

   If oq_MakePrecise is false (default), the standard version is used that returns 6 digits after the decimal point.
   If oq_MakePrecise is true, the conversion uses a variant of C_SCLString::FloatToStr where the number of
   decimals can be specified. Using a large number it returns more precise representations of the float values.

   \param[in]  of64_Value        Value to convert
   \param[in]  oq_MakePrecise    Flag if to use more than 6 digits after decimal point

   \return
   Value converted to string
*/
//----------------------------------------------------------------------------------------------------------------------
C_SCLString C_OSCExportUti::h_FloatToStrCutZeroes(const float64 of64_Value, const bool oq_MakePrecise)
{
   C_SCLString c_Return;

   if (oq_MakePrecise == true)
   {
      c_Return = C_SCLString::FloatToStr(of64_Value, 100);
   }
   else
   {
      c_Return = C_SCLString::FloatToStr(of64_Value);
   }

   // defensive check
   if (c_Return.Pos('.') > 0)
   {
      // cut trailing zeros
      while ((c_Return.IsEmpty() == false) && (c_Return[c_Return.Length()] == '0') &&
             (c_Return.Pos(".") != (c_Return.Length() - 1)))
      {
         c_Return.Delete(c_Return.Length(), 1);
      }
   }
   return c_Return;
}

//----------------------------------------------------------------------------------------------------------------------
/*! \brief  Float32 version of C_OSCExportDataPool::h_FloatToStringCutZeroes

   \param[in]  of32_Value        Value to convert
   \param[in]  oq_MakePrecise    Flag if to use more than 6 digits after decimal point

   \return
   Value converted to string
*/
//----------------------------------------------------------------------------------------------------------------------
C_SCLString C_OSCExportUti::h_FloatToStrCutZeroes(const float32 of32_Value, const bool oq_MakePrecise)
{
   return h_FloatToStrCutZeroes(static_cast<float64>(of32_Value), oq_MakePrecise);
}
